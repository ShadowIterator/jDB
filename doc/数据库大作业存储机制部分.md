# 数据库大作业存储机制部分

## 储存部分结构

储存部分主要分为三个模块，`tuple`，`pager`和`B+Tree`，其中`pager`的主要功能是为`B+Tree`提供一个抽象的页结构，并提供缓存和线程锁机制，使得`B+Tree`不需要关注过于底层的部分。`B+Tree`则是把索引和数据组织在一起，存到页结构上，提供一个抽象的表结构，为查询模块提供服务，`tuple`提供一个元组的表示方法，提供元组的序列化、反序列化、取得元组某个属性、主键等操作。

![store_arch](./asset/store_arch.png)

## `pager`

`pager`主要对外提供一个抽象的页结构，对内实现缓存机制(暂时还未实现线程锁机制)，达到解耦与提高程序效率的目的。

### 对外接口

* `open(db_file_name)`: 打开一个数据文件，在这个文件上提供页结构
* `close()`: 关闭这个`pager`
* `get(page_id)`: 返回一个指定的页
* `write(page)`: 写回一个指定的页
* `newPage()`: 返回一个新的、未使用的页
* `delPage(id)`: 删除一页(使得这页变为空闲状态)

### 一个实现

在当前版本的`pager`实现中，我们采用了hash缓存的机制，设缓存池`page_pool`有$N$个page，当`get(page_id)`被调用时，首先查看`page_pool[page_id % N].id`是否等于`page_id`，如果相等，就直接从缓存返回，否则发生换页`load(page_id)`把这一页从外存上载入进来，再返回这一页。当`write(page)`被调用时，同样检查这一页是否在缓存中，如果在缓存中则直接写入缓存，否则换页后写入缓存。

换页`load(page_id)`指将`page_pool[page_id % N]`这一页写入外存并在外存中载入`page_id`这一页到`page_pool[page_id % N]`这个位置。

## `tuple`

`tuple`主要提供元组在内存中的直观表示方法。

### 对外接口

* 内部类`tupleDesc`：用于描述一个`tuple`的各种性质，比如记录每一个属性的名字、约束、类型、默认值等，与`tuple`是一对多的关系。
  * `serialize()`: 序列化
  * `deserialize(byte[])`: 反序列化
  * `tupleSize()`: 返回对应`tuple`序列化之后的大小
  * `descSize()`: 返回`tupleDesc`序列化之后的大小
  * `getAttr_name(int k)`: 得到第k个属性的名字
  * `getAttr_constraint(int k)`: 得到第k个属性的约束
  * ...
* `serialize(tupleDesc desc)`: 序列化，这个`tuple`用`desc`描述
* `deserialize(byte[] b, tupleDesc desc)`: 从`b`中反序列化出一个满足`desc`描述的`tuple`
* `getAttr(int k)`: 返回第k个属性的值

## B+树实现

* 节点结构

  * 成员变量

    每个节点都对应一个pager分配的页片，在节点中存储的信息有：

    是否为叶，是否为根的标记变量，父节点页片号，节点自身页片号，以及键的类型标识如果是叶节点，还会存储叶节点链表前后节点的页片号；对于内部非叶节点，维护的是键与子节点页片号的映射，对于叶子节点，维护的是键与元组的映射。

  * 节点接口

  1. 增删改查

     此部分与普通b+树的增删改查并无太大区别，被调用的接口由根开始根据键值向下查找需要进行操作的叶子节点的位置，进行相应操作后，再根据树的阶数由下至上判断是否需要进行调整。

  2. 节点序列化与反序列化

     自定格式实现单个节点的内容写入页片以及从页片(page)中读出还原节点结构的接口。反序列化主要用于通过页片读入节点信息时使用，如查找一个节点的父节点时。序列化主要用于，在上述增删改查接口被调用时，如果节点内容或结构发生改变，则将改变后的节点信息在被其它节点访问前及时写回页片。事实上同一节点多次写回页片并不会出现逻辑上的错误，但为了减少冗余的访问，在一次增/删/改/查的递归过程中，一个节点只会在内容改变后在合适的位置被写回一次。

* b树结构

  * 成员变量

    b+树内部存储的变量有，阶数，叶子节点组成链表的头结点编号，根节点，分页器pager，待存储数据表的元组描述符(内部存储了约束，属性，主键等信息)，以及存储b树自身信息的页片id。

  * 接口实现

    标准的增删改查接口只需调用根节点的对应接口即可。此外还需实现初始化等接口打开数据库文件，初始化pager供节点使用，并将b+树的信息以自定义的格式存储到信息页片中、从数据库文件中恢复b+树结构等，此部分内容随着大作业其余部分的完成可能还需要进行修改。

## 测试与验证

我们对每一部分进行了单独的测试。

* `B+Tree`的测试在`BPlusTree.main`中
* `tuple`和`pager`的测试在`HeapFile.main`中，这里为了简单起见用`HeapFile`代替了`B+Tree`调用`pager`和`tuple`的接口达到测试的目的

## 作者

* 张佳麟 2016013256
* 洪方舟 2016013259
* 李仁杰 2016013271