# JDB通信模块

## 概述

本数据库实现了一个有图形界面的客户端以及一个服务端。服务端接受客户端的连接，接受客户端传来的sql语句，交给执行模块执行后将结果序列化后通过网络传输返回给客户端。客户端的界面及使用请参考运行方法章节。

## 实现细节

该部分涉及的代码存储于`net`文件夹与`gui`文件夹

### 服务端

服务端主要类为`jDBServer`，存储于`net/jDBServer.java`

服务端首先初始化一个元数据管理器，接着进入无限循环阻塞式的接受socket连接，每次接受一个socket之后开启一个新的进程；该进程阻塞式的读取所有客户端传来的sql语句，交给执行模块执行后拿到`SQLResult`类的实例，通过调用`ObjectOutputStream`类的`writeObject`方法，将结果实例序列化后通过socket传输给客户端。

值得注意的是本系统采用的是短连接设计，也即每次客户端发起执行sql请求时均需要重新连接socket，每次sql执行结束，传回结果后，服务端均关闭socket。采用这种设计虽然可能带来一定的额外消耗(每次重新连接socket的耗时)，但是这种设计可以避免长连接设计模式中较为麻烦的状态记录，并且短连接的代码更为简洁，鲁棒性较强。

服务端的设计中有一个较为麻烦的地方，由于存储模块使用了buffer的设计，因此关闭服务端的时候需要将buffer完全写回磁盘中，因此就需要捕捉服务端退出这一事件。经过一些网上的搜索，我们发现java程序被强制中断(Ctrl-C)的时候并不会抛出异常，因此需要使用hook来捕捉。在服务端开始运行之后马上调用`Runtime.getRuntime().addShutdownHook`函数添加钩子类实例，这样当程序被中断的时候，java的运行时会自动调用钩子类实例的`run()`函数，就可以在该函数中执行一些善后的工作，例如本系统中需要将buffer写回磁盘。这里的钩子类实际上是`Thread`类的子类，因此本质上，当程序被中断的时候，java运行时新建了一个用户指定的善后进程。

## 客户端

客户端类为`net/jDBClient.java`，图形界面类为`gui/JDBGUI.java`

客户端使用了Swing框架实现了图形界面；每次用户点击执行按钮时，文本框中的sql语句被读出，新建TCP连接，将sql语句通过socket传输，接受序列化的`SQLResult`实例后反序列化，根据结果类型读出所需数据，显示在图形界面上。

具体的界面设计及操作方法请参见运行方法章节。

